<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Primal Front: Apex Predator</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020202; font-family: 'Segoe UI', monospace; user-select: none; }
        canvas { display: block; }

        /* UI LAYERS */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }
        
        /* SCREENS */
        #menu-screen, #shop-screen, #lab-screen, #upgrade-screen, #archive-screen {
            background: rgba(2, 2, 2, 0.96); pointer-events: auto;
            align-items: center; justify-content: center; z-index: 50;
            overflow-y: auto;
        }

        h1 { font-size: 70px; color: #4caf50; margin: 0; text-shadow: 0 0 30px #4caf50; letter-spacing: 5px; text-align: center; }
        h2 { color: #fff; margin-bottom: 30px; text-align: center; }
        h3 { color: #fff; margin: 0; }
        
        .btn {
            background: #111; color: white; border: 2px solid #4caf50;
            padding: 15px 40px; font-size: 24px; cursor: pointer;
            margin: 10px; transition: 0.2s; font-family: monospace; font-weight: bold;
            min-width: 250px; text-transform: uppercase;
        }
        .btn:hover { background: #4caf50; color: #000; box-shadow: 0 0 25px #4caf50; transform: scale(1.05); }
        
        .btn-blue { border-color: #00e5ff; } .btn-blue:hover { background: #00e5ff; box-shadow: 0 0 25px #00e5ff; }
        .btn-purple { border-color: #d500f9; } .btn-purple:hover { background: #d500f9; box-shadow: 0 0 25px #d500f9; }
        .btn-orange { border-color: #ff9100; } .btn-orange:hover { background: #ff9100; box-shadow: 0 0 25px #ff9100; }

        .btn-fixed-close {
            position: fixed; top: 20px; right: 20px;
            width: 50px; height: 50px; border-radius: 50%;
            border: 2px solid #e53935; background: #111; color: #e53935;
            font-size: 24px; font-weight: bold; cursor: pointer; z-index: 100;
            display: flex; align-items: center; justify-content: center;
        }
        .btn-fixed-close:hover { background: #e53935; color: white; box-shadow: 0 0 20px #e53935; }

        .currency-display {
            font-size: 24px; color: #fdd835; margin-bottom: 20px; font-weight: bold;
            text-shadow: 0 0 10px #fdd835; text-align: center;
        }

        .grid-container {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
            max-width: 1100px; padding-bottom: 50px;
        }
        .item-card {
            background: #1a1a1a; border: 1px solid #444; padding: 15px;
            text-align: center; cursor: pointer; transition: 0.2s; position: relative;
            overflow: hidden; min-height: 120px; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .item-card:hover { border-color: #fff; background: #252525; transform: translateY(-5px); }
        .item-card.owned { border-color: #4caf50; }
        .item-card.selected { background: linear-gradient(45deg, #1b5e20, #000); border-color: #69f0ae; box-shadow: 0 0 15px #4caf50; }

        #loadout-display { display: flex; gap: 15px; margin-bottom: 30px; justify-content: center; flex-wrap: wrap; max-width: 900px; }
        .canister {
            width: 90px; height: 110px; border: 2px dashed #444; border-radius: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: #111; color: #666; font-size: 11px; text-align: center; transition: 0.3s;
        }
        .canister.filled { border-style: solid; border-color: #00e5ff; color: #fff; box-shadow: 0 0 15px rgba(0, 229, 255, 0.3); }

        .evo-section { border: 1px solid #d500f9; padding: 20px; margin-bottom: 20px; border-radius: 8px; background: rgba(20, 0, 20, 0.5); text-align: center; width: 60%; }
        .upgrade-row { display: flex; align-items: center; justify-content: space-between; background: #111; padding: 15px; margin-bottom: 10px; border: 1px solid #333; width: 600px; }
        .pips { display: flex; gap: 5px; } .pip { width: 15px; height: 15px; background: #333; border: 1px solid #555; }
        .pip.active { background: #00e5ff; box-shadow: 0 0 5px #00e5ff; }

        #hud-container { position: absolute; bottom: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; z-index: 10; }
        .panel { background: rgba(10, 10, 10, 0.85); padding: 15px; border-radius: 4px; border: 1px solid #333; color: white; box-shadow: 0 0 15px rgba(0,0,0,0.8); backdrop-filter: blur(5px); }
        .stat-row { display: flex; justify-content: space-between; width: 240px; margin-bottom: 5px; font-size: 14px; }
        .stat-val { font-weight: bold; color: #4caf50; }
        
        #interactions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: none; z-index: 10; }
        .prompt { background: rgba(0,0,0,0.8); color: white; padding: 12px 25px; border-radius: 30px; font-size: 16px; border: 1px solid #4caf50; margin-bottom: 10px; display: none; box-shadow: 0 0 15px #4caf50; }
        .key { color: #fdd835; font-weight: bold; }

        #controls-help { position: absolute; top: 20px; right: 20px; text-align: right; color: rgba(255,255,255,0.4); font-size: 12px; pointer-events: none; }
        #game-over-screen { background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 20; pointer-events: auto; }

        /* ARCHIVE SPECIFIC */
        #archive-controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; max-width: 800px; }
        .skin-toggle { background: #222; border: 1px solid #555; color: #888; padding: 8px 15px; cursor: pointer; }
        .skin-toggle.active { background: #00e5ff; color: #000; border-color: #fff; box-shadow: 0 0 15px #00e5ff; }
    </style>
</head>
<body>

    <div id="menu-screen" class="ui-layer" style="display: flex;">
        <h1>PRIMAL FRONT</h1>
        <h2 style="letter-spacing: 2px; color:#888;">GENETIC WARFARE</h2>
        <div class="currency-display">COINS: <span id="menu-coins">0</span></div>
        <button class="btn" onclick="startGame()">DEPLOY SWARM</button>
        <button class="btn btn-purple" onclick="openUpgrades()">EVO UPGRADES</button>
        <button class="btn btn-blue" onclick="openLab()">MUTATION LAB</button>
        <button class="btn" onclick="openShop()">SKIN ARMORY</button>
        <button class="btn btn-orange" onclick="openArchive()">SPECIES ARCHIVE</button>
    </div>

    <div id="archive-screen" class="ui-layer" style="display: none;">
        <button class="btn-fixed-close" onclick="closeArchive()">âœ•</button>
        <h1 style="color:#ff9100; text-shadow: 0 0 30px #ff9100; margin-top: 20px; font-size: 50px;">VISUAL DATABASE</h1>
        <p style="color:#aaa;">Select a skin to preview evolution stages</p>
        <div id="archive-controls"></div>
        <canvas id="archiveCanvas" width="1000" height="400" style="border: 1px solid #333; background: #050505;"></canvas>
    </div>

    <div id="upgrade-screen" class="ui-layer" style="display: none;">
        <button class="btn-fixed-close" onclick="closeUpgrades()">âœ•</button>
        <h1 style="color:#d500f9; text-shadow: 0 0 30px #d500f9; margin-top: 60px;">HIVE EVOLUTION</h1>
        <div class="currency-display">COINS: <span id="upgrade-coins">0</span></div>
        <div id="upgrade-list"></div>
    </div>

    <div id="lab-screen" class="ui-layer" style="display: none;">
        <button class="btn-fixed-close" onclick="closeLab()">âœ•</button>
        <h1 style="color:#00e5ff; text-shadow: 0 0 30px #00e5ff; margin-top: 60px;">GENE LAB</h1>
        <div class="currency-display">COINS: <span id="lab-coins">0</span></div>
        <div class="evo-section">
            <h3 style="color:#d500f9; margin-bottom:10px;">ðŸ§¬ GENE SPLICING</h3>
            <p style="color:#aaa; font-size:12px;">Modify starting evolutionary stage.</p>
            <button id="evo-btn" class="btn" style="padding:5px 20px; font-size:16px; border-color:#d500f9;" onclick="toggleStartStage()">STARTING FORM: LARVA</button>
        </div>
        <div id="loadout-display"></div>
        <div style="text-align: center;">
            <button class="btn" onclick="clearLoadout()" style="padding: 5px 20px; font-size: 16px; min-width: 100px; border-color:#e53935; background:#220000; margin-bottom: 20px;">RESET SLOTS</button>
        </div>
        <div id="lab-grid" class="grid-container"></div>
    </div>

    <div id="shop-screen" class="ui-layer" style="display: none;">
        <button class="btn-fixed-close" onclick="closeShop()">âœ•</button>
        <h1 style="margin-top: 60px;">ARMORY</h1>
        <div class="currency-display">COINS: <span id="shop-coins">0</span></div>
        <div id="shop-grid" class="grid-container"></div>
    </div>

    <div id="game-over-screen" class="ui-layer">
        <h1 style="color: #e53935; text-shadow: 0 0 30px red;">BROOD ELIMINATED</h1>
        <p style="color: #fff; font-size: 24px; margin: 10px 0;">Score: <span id="final-score" style="color:#4caf50; font-weight:bold;">0</span></p>
        <p style="color: #aaa; font-size: 18px; margin-bottom: 30px;">Coins Earned: <span id="final-coins" style="color:#fdd835;">0</span></p>
        <button class="btn" onclick="returnToMenu()">RETURN TO HIVE</button>
    </div>

    <div id="hud-ui" class="ui-layer" style="display: none;">
        <div id="controls-help">
            [WASD] Move &nbsp; [MOUSE] Shoot<br>
            [Q] Next Unit &nbsp; [E] Select Strongest<br>
            [SPACE] Evolve &nbsp; [X] Dismiss Weakest<br>
            [R] Recruit &nbsp; [F] Harvest
        </div>
        <div id="interactions">
            <div id="recruit-prompt" class="prompt">
                Target Downed<br>
                <span class="key">[R]</span> Assimilate &nbsp;|&nbsp; <span class="key">[F]</span> Consume
            </div>
        </div>
        <div id="hud-container">
            <div class="panel">
                <div class="stat-row"><span>BIOMASS</span> <span id="bio-val" class="stat-val">0</span></div>
                <div class="stat-row"><span>COINS</span> <span id="coin-val" class="stat-val" style="color:#fdd835">0</span></div>
                <div class="stat-row"><span>HIVE SIZE</span> <span id="squad-val">3/10</span></div>
                <div class="stat-row"><span>CURRENT FORM</span> <span id="form-val" style="color:#aaa">Larva</span></div>
                <div id="evo-ready" style="color: #fdd835; font-weight:bold; margin-top: 5px; display: none; text-shadow: 0 0 5px yellow;">âš  EVOLUTION READY [SPACE]</div>
            </div>
            <div class="panel" style="text-align: right;">
                <div style="font-size: 10px; color: #666; letter-spacing: 1px;">GENETIC STRAIN</div>
                <div id="mutation-val" style="font-size: 14px; font-weight: bold; color: white;">Stable</div>
                <div id="mutation-desc" style="font-size: 10px; color: #888; max-width: 150px; margin-left: auto;">Standard stats</div>
                <div id="player-buff" style="font-size: 10px; color: #00e5ff; margin-top:5px;">âš¡ DIRECT CONTROL: 1.5x STATS</div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // --- SAVE SYSTEM ---
    let playerCoins = parseInt(localStorage.getItem('pf_coins') || '0');
    let unlockedSkins = JSON.parse(localStorage.getItem('pf_skins') || '["DEFAULT"]');
    let equippedSkin = localStorage.getItem('pf_equipped') || 'DEFAULT';
    let activeLoadout = JSON.parse(localStorage.getItem('pf_loadout') || '[]');
    let playerUpgrades = JSON.parse(localStorage.getItem('pf_upgrades') || '{"hiveCap":0, "startCount":0, "startEvo":0}');
    let preferStartStage = parseInt(localStorage.getItem('pf_prefStage') || '1'); 

    const UPGRADE_DATA = {
        hiveCap: { name: "HIVE CAPACITY", max: 5, cost: [500, 1000, 2000, 4000, 8000], desc: "+2 Max Unit Capacity per level" },
        startCount: { name: "STARTING SWARM", max: 2, cost: [2500, 7500], desc: "+1 Starting Unit per level" },
        startEvo: { name: "GENETIC MEMORY", max: 2, cost: [5000, 15000], desc: "Unlock Starting at Higher Tiers" }
    };

    // UPDATED SKINS WITH TEXTURE DEFINITIONS
    const SKINS = {
        DEFAULT: { name: "Bio-Standard", cost: 0, color: '#4caf50', type: 'organic' },
        NEON:    { name: "Cyber Neon", cost: 200, color: '#00e5ff', type: 'digital' },
        MAGMA:   { name: "Magma Crust", cost: 500, color: '#ff3d00', type: 'magma' }, 
        GOLD:    { name: "Royal Gold", cost: 1000, color: '#ffd700', type: 'metallic' },
        VOID:    { name: "Void Walker", cost: 2000, color: '#6a1b9a', type: 'cosmic' },
        GLITCH:  { name: "Sys.Error", cost: 5000, color: '#fff', type: 'glitch' }
    };

    const MUTATIONS = {
        NONE:     { name: "Stable", desc: "No enhancement", color: '#444', cost: 0, stat: {} },
        STINGER:  { name: "Stinger", desc: "Melee Damage Aura", color: '#e65100', cost: 50, stat: { melee: true } },
        WINGS:    { name: "Wings", desc: "+80% Speed", color: '#90caf9', cost: 75, stat: { speed: 1.8 } },
        OVERDRIVE:{ name: "Overdrive", desc: "+150% Speed", color: '#ff9100', cost: 200, stat: { speed: 2.5 } }, 
        TESLA:    { name: "Tesla", desc: "Auto Electric Zap", color: '#0288d1', cost: 100, stat: { tesla: true } },
        MULTI:    { name: "Hydra", desc: "Triple Shot", color: '#c6ff00', cost: 120, stat: { multi: true } },
        SNIPER:   { name: "Railgun", desc: "High Dmg/Range", color: '#607d8b', cost: 100, stat: { sniper: true, range: 2.0 } },
        HEAVY:    { name: "Titan", desc: "+200% HP, Armor", color: '#3e2723', cost: 150, stat: { hp: 3.0, size: 1.4, speed: 0.6 } },
        VAMPIRE:  { name: "Leech", desc: "Life Steal", color: '#880e4f', cost: 200, stat: { lifesteal: true } },
        GHOST:    { name: "Phantom", desc: "Stealth", color: '#cfd8dc', cost: 100, stat: { stealth: true } },
        ACID:     { name: "Toxic", desc: "Acid Bullets", color: '#76ff03', cost: 120, stat: { acid: true, dmg: 1.2 } },
        REGEN:    { name: "Regen", desc: "Rapid Heal", color: '#ff4081', cost: 150, stat: { regen: true } },
        NECRO:    { name: "BROODMOTHER", desc: "Kills recruit victim", color: '#d500f9', cost: 5000, stat: { necro: true } },
        SPIKE:    { name: "Thorns", desc: "Reflects Dmg on Hit", color: '#8d6e63', cost: 300, stat: { thorns: true } },
        FROST:    { name: "Frostbite", desc: "Slows Enemies", color: '#80deea', cost: 400, stat: { frost: true } },
        BOOM:     { name: "Volatile", desc: "Explodes on Death", color: '#ff3d00', cost: 350, stat: { boom: true } },
        FRENZY:   { name: "Berserker", desc: "Low HP = Fast Atk", color: '#ff1744', cost: 300, stat: { frenzy: true } }
    };

    let GAME_STATE = 'MENU';
    let STATE = {};
    let MAX_SQUAD = 10;
    
    // --- BACKGROUND VISUALS ---
    class BioBackground {
        constructor() {
            this.nodes = [];
            for(let i=0; i<40; i++) {
                this.nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.2,
                    vy: (Math.random() - 0.5) * 0.2,
                    r: Math.random() * 50 + 20
                });
            }
        }
        update() {
            this.nodes.forEach(n => {
                n.x += n.vx; n.y += n.vy;
                if(n.x < -100) n.x = canvas.width + 100;
                if(n.x > canvas.width + 100) n.x = -100;
                if(n.y < -100) n.y = canvas.height + 100;
                if(n.y > canvas.height + 100) n.y = -100;
            });
        }
        draw(ctx) {
            ctx.fillStyle = '#020202';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = 'rgba(20, 50, 20, 0.15)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=0; i<this.nodes.length; i++) {
                let n1 = this.nodes[i];
                for(let j=i+1; j<this.nodes.length; j++) {
                    let n2 = this.nodes[j];
                    let d = Math.hypot(n1.x - n2.x, n1.y - n2.y);
                    if(d < 300) {
                        ctx.moveTo(n1.x, n1.y);
                        ctx.lineTo(n2.x, n2.y);
                    }
                }
            }
            ctx.stroke();

            this.nodes.forEach(n => {
                const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
                grad.addColorStop(0, 'rgba(30, 60, 30, 0.1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(n.x, n.y, n.r, 0, Math.PI*2); ctx.fill();
            });
        }
    }
    const bgSystem = new BioBackground();

    // --- VISUAL CLASSES ---
    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 40; this.vy = -1.5;
        }
        update() { this.y += this.vy; this.life--; }
        draw(context) {
            context.globalAlpha = Math.max(0, this.life / 40);
            context.fillStyle = this.color; context.font = "bold 16px monospace";
            context.shadowColor = 'black'; context.shadowBlur = 4;
            context.fillText(this.text, this.x, this.y);
            context.shadowBlur = 0; context.globalAlpha = 1;
        }
    }

    class Particle {
        constructor(x, y, color, speed, size, life) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            this.color = color; this.size = size; this.life = life; this.maxLife = life;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.life--; this.size *= 0.95;
        }
        draw(context) {
            context.globalAlpha = this.life / this.maxLife;
            context.fillStyle = this.color;
            context.beginPath(); context.arc(this.x, this.y, this.size, 0, Math.PI*2); context.fill();
            context.globalAlpha = 1;
        }
    }
    
    // VISUAL EFFECT FOR STINGER
    class SpikeThrust {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle; this.life = 10;
        }
        update() { this.life--; }
        draw(context) {
            context.save(); context.translate(this.x, this.y); context.rotate(this.angle);
            context.globalAlpha = this.life / 10;
            context.fillStyle = '#fff'; 
            context.shadowColor = '#e65100'; context.shadowBlur = 20;
            context.beginPath(); context.moveTo(0, 0); context.lineTo(60, -10); context.lineTo(40, 0); context.lineTo(60, 10); context.closePath(); context.fill();
            context.restore(); context.globalAlpha = 1; context.shadowBlur = 0;
        }
    }

    // --- ENTITY CLASS ---
    class Entity {
        constructor(x, y, team, stage = 1, mutations = ['NONE']) {
            this.x = x; this.y = y;
            this.team = team; this.stage = stage;
            this.mutations = Array.isArray(mutations) ? mutations : [mutations];
            
            this.stats = { speed: 1, hp: 1, size: 1, dmg: 1 };
            
            this.mutations.forEach(key => {
                const mStat = MUTATIONS[key].stat;
                if(mStat.speed) this.stats.speed *= mStat.speed;
                if(mStat.hp) this.stats.hp *= mStat.hp;
                if(mStat.size) this.stats.size *= mStat.size;
                if(mStat.dmg) this.stats.dmg *= mStat.dmg;
                ['melee','tesla','multi','sniper','lifesteal','stealth','acid','regen','necro','thorns','frost','boom','frenzy'].forEach(flag => {
                    if(mStat[flag]) this.stats[flag] = true;
                });
            });

            const baseSpd = stage === 1 ? 2.5 : (stage === 2 ? 3.5 : (stage === 3 ? 2.0 : 1.5));
            this.speed = Math.min(this.stats.speed * baseSpd, 15);
            
            const stageMulti = stage === 1 ? 1 : (stage === 2 ? 2.5 : (stage === 3 ? 6 : 15));
            this.hp = 100 * stageMulti * this.stats.hp;
            this.maxHp = this.hp;
            
            let baseSize = 12;
            if(stage === 2) baseSize = 18;
            if(stage === 3) baseSize = 28;
            if(stage === 4) baseSize = 40;
            if(stage === 5) baseSize = 55;
            this.size = this.stats.size * baseSize;
            
            this.angle = 0;
            this.downed = false;
            this.dead = false;
            this.lastDamageTime = 0;
            this.lastZapTime = 0;
            this.animOffset = Math.random() * 100;
            this.slowTimer = 0;
            
            // For Glitch effect
            this.glitchOffset = {x:0, y:0};
        }

        applyPassives() {
            if (this.downed || this.dead) return;
            const isPlayerControlled = (this.team === 'player' && this === STATE.squad[STATE.playerIndex]);

            if(this.slowTimer > 0) this.slowTimer--;

            // Regen Logic
            let regenRate = this.maxHp / 1800; 
            let regenThreshold = 5000;
            if (this.stats.regen) { regenRate *= 8; regenThreshold = 0; } 
            
            if (Date.now() - this.lastDamageTime > regenThreshold) {
                if (this.hp < this.maxHp) {
                    this.hp = Math.min(this.maxHp, this.hp + regenRate);
                    if(this.stats.regen && Math.random() < 0.1) spawnParticles(this.x, this.y, '#ff4081', 1, 3);
                }
            }

            // Tesla Logic
            if (this.stats.tesla && Date.now() - this.lastZapTime > 800) {
                const targets = this.team === 'player' ? STATE.enemies : STATE.squad;
                const zapTarget = targets.find(t => !t.dead && !t.downed && Math.hypot(t.x - this.x, t.y - this.y) < 180);
                if (zapTarget) {
                    let dmg = 10; if(isPlayerControlled) dmg *= 1.5; 
                    zapTarget.takeDamage(dmg, this);
                    this.lastZapTime = Date.now();
                    spawnParticles(zapTarget.x, zapTarget.y, '#00e5ff', 5, 2);
                    ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = '#00e5ff';
                    ctx.beginPath(); ctx.moveTo(this.x, this.y); 
                    ctx.lineTo((this.x+zapTarget.x)/2 + (Math.random()*20-10), (this.y+zapTarget.y)/2 + (Math.random()*20-10));
                    ctx.lineTo(zapTarget.x, zapTarget.y); ctx.stroke(); ctx.shadowBlur = 0;
                }
            }

            // Melee (Stinger) Logic
            if (this.stats.melee) {
                const targets = this.team === 'player' ? STATE.enemies : STATE.squad;
                let hitAnyone = false;
                targets.forEach(t => {
                    if (!t.dead && !t.downed && Math.hypot(t.x - this.x, t.y - this.y) < this.size + t.size + 10) {
                        let dmg = 2; if(isPlayerControlled) dmg *= 1.5; 
                        t.takeDamage(dmg, this);
                        hitAnyone = true;
                        if(Math.random() < 0.1) spawnParticles(t.x, t.y, '#e65100', 3, 2);
                    }
                });

                if(hitAnyone && Math.random() < 0.2) {
                    STATE.effects.push(new SpikeThrust(this.x, this.y, this.angle));
                }
            }
        }

        updateAI(target) {
            if (this.downed || this.dead) return;
            this.applyPassives();

            let currSpeed = this.speed;
            if(this.slowTimer > 0) currSpeed *= 0.5;

            if (target) {
                let dx = target.x - this.x;
                let dy = target.y - this.y;
                let dist = Math.hypot(dx, dy);
                let detectRange = 9999;
                if (target.stats.stealth) detectRange = 250;

                if (dist < detectRange) {
                    let stopDist = this.stats.melee ? 0 : this.size + 150;
                    if (dist > stopDist) {
                        this.x += (dx / dist) * currSpeed;
                        this.y += (dy / dist) * currSpeed;
                    }
                    this.angle = Math.atan2(dy, dx);
                    
                    let rate = 0.015;
                    if (this.stats.frenzy) {
                        const hpPct = this.hp / this.maxHp;
                        if(hpPct < 0.5) rate *= 2;
                        if(hpPct < 0.2) rate *= 4;
                    }

                    if (!this.stats.melee && Math.random() < rate) shoot(this);
                }
            }
        }

        takeDamage(amt, source) {
            this.hp -= amt;
            this.lastDamageTime = Date.now();
            
            if (this.stats.thorns && source && source !== this) {
                source.hp -= (amt * 0.5); 
                spawnParticles(source.x, source.y, '#8d6e63', 2, 2);
            }
            if (source && source.stats.frost) {
                this.slowTimer = 60; 
                spawnParticles(this.x, this.y, '#80deea', 1, 2);
            }

            const textColor = this.team === 'enemy' ? '#ff5252' : '#ffffff';
            if(Math.random() < 0.5) {
                STATE.texts.push(new FloatingText(this.x, this.y - this.size, Math.round(amt), textColor));
            }

            if(this.stats.acid && Math.random() < 0.3) spawnParticles(this.x, this.y, '#76ff03', 2, 4); 
            else spawnParticles(this.x, this.y, this.team==='player'?'#4caf50':'#e53935', 2, 3);
            
            if (this.hp <= 0) handleDeath(this, source);
        }

        draw(context) {
            if (this.dead) return;
            
            let baseColor, glowColor, skinType;
            
            if (this.team === 'player') {
                const skin = SKINS[equippedSkin];
                baseColor = skin.color;
                skinType = skin.type;
                glowColor = skinType === 'digital' ? skin.color : null;
                
                if (skinType === 'cosmic') { baseColor = '#1a0033'; glowColor = '#9c27b0'; }
                if (skinType === 'magma') { baseColor = '#220a0a'; glowColor = '#ff3d00'; }
                if (skinType === 'glitch') {
                    if(Math.random() < 0.1) {
                        this.glitchOffset.x = (Math.random()-0.5)*10;
                        this.glitchOffset.y = (Math.random()-0.5)*10;
                    } else { this.glitchOffset.x = 0; this.glitchOffset.y = 0; }
                }
            } else {
                baseColor = this.downed ? '#444' : '#d32f2f';
                skinType = 'enemy';
                glowColor = this.downed ? null : '#ff0000';
            }

            if(this.stats.stealth) context.globalAlpha = 0.3;
            if(this.slowTimer > 0) { context.shadowColor = '#00e5ff'; context.shadowBlur = 10; baseColor = '#b2ebf2'; }
            
            context.save();
            if(skinType === 'glitch') context.translate(this.glitchOffset.x, this.glitchOffset.y);
            drawCreatureBody(context, this, baseColor, glowColor, skinType);
            context.restore();

            context.shadowBlur = 0; context.globalAlpha = 1.0;
            context.setTransform(1,0,0,1,0,0); 

            if (!this.downed && context === ctx) {
                const barW = this.size * 1.5;
                const barY = this.y - this.size - 40; 
                context.fillStyle = '#000'; context.fillRect(this.x - barW/2, barY, barW, 6);
                context.fillStyle = (this.stats.regen && this.hp < this.maxHp) ? '#ff4081' : (this.team === 'player' ? '#4caf50' : '#d32f2f');
                context.fillRect(this.x - barW/2 + 1, barY + 1, (barW-2) * (this.hp / this.maxHp), 4);
            }
        }
    }

    // --- MAIN GAME LOGIC ---

    function initGame() {
        document.getElementById('menu-coins').innerText = playerCoins;
    }

    function startGame() {
        GAME_STATE = 'PLAYING';
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('hud-ui').style.display = 'block';

        STATE = {
            gameTime: 0, biomass: 0, sessionCoins: 0, score: 0,
            squad: [], enemies: [], projectiles: [], particles: [], effects: [], texts: [],
            playerIndex: 0, lastShot: 0
        };

        MAX_SQUAD = 10 + (playerUpgrades.hiveCap * 2);
        const startCount = 3 + playerUpgrades.startCount;
        let startStage = 1;
        if(playerUpgrades.startEvo > 0 && preferStartStage > 1) {
            startStage = Math.min(preferStartStage, playerUpgrades.startEvo + 1); 
        }

        const cx = canvas.width/2;
        const cy = canvas.height/2;

        for(let i=0; i<startCount; i++) {
            const m = activeLoadout[i] || 'NONE';
            const offset = (i - (startCount/2)) * 60;
            STATE.squad.push(new Entity(cx + offset, cy + Math.abs(offset)*0.5, 'player', startStage, [m]));
        }

        updateHUD();
        loop();
    }

    function returnToMenu() {
        GAME_STATE = 'MENU';
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('hud-ui').style.display = 'none';
        document.getElementById('menu-screen').style.display = 'flex';
        document.getElementById('menu-coins').innerText = playerCoins;
    }

    function loop() {
        if (GAME_STATE !== 'PLAYING') return;

        STATE.gameTime++;
        STATE.score++;

        bgSystem.update();
        bgSystem.draw(ctx);

        const difficulty = STATE.score + (STATE.gameTime / 2);
        const spawnChance = Math.min(0.005 + (difficulty / 350000), 0.08); 
        const maxEnemies = Math.min(5 + Math.floor(difficulty / 1000), 30);

        if (STATE.enemies.length < maxEnemies && Math.random() < spawnChance) {
            spawnEnemy(difficulty);
        }

        updateEntities();
        updateProjectiles();
        updateParticles();

        STATE.particles.forEach(p => p.draw(ctx));
        STATE.effects.forEach(e => e.draw(ctx));
        STATE.texts.forEach(t => t.draw(ctx));
        
        STATE.enemies.forEach(e => e.draw(ctx));
        STATE.squad.forEach((s, i) => {
            s.draw(ctx);
            if (i === STATE.playerIndex) {
                const pulse = Math.sin(Date.now() / 150) * 2;
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.setLineDash([8, 8]);
                ctx.beginPath(); ctx.arc(s.x, s.y, s.size + 25 + pulse, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
            }
        });

        updateHUD();
        requestAnimationFrame(loop);
    }
    
    function updateHUD() {
        if (GAME_STATE !== 'PLAYING') return;

        document.getElementById('bio-val').innerText = Math.floor(STATE.biomass);
        document.getElementById('coin-val').innerText = playerCoins + STATE.sessionCoins;
        document.getElementById('squad-val').innerText = STATE.squad.length + "/" + MAX_SQUAD;

        const player = STATE.squad[STATE.playerIndex];
        if (player) {
            let form = "Larva";
            if(player.stage===2) form="Worker";
            if(player.stage===3) form="Hunter";
            if(player.stage===4) form="Titan";
            if(player.stage===5) form="Queen";
            document.getElementById('form-val').innerText = form;

            const mKey = player.mutations.find(m => m !== 'NONE') || 'NONE';
            const mData = MUTATIONS[mKey];
            const mEl = document.getElementById('mutation-val');
            mEl.innerText = mData.name;
            mEl.style.color = mData.color;
            document.getElementById('mutation-desc').innerText = mData.desc;

            const cost = player.stage * 100;
            const canEvo = player.stage < 5 && STATE.biomass >= cost;
            document.getElementById('evo-ready').style.display = canEvo ? 'block' : 'none';
        }

        const recruitPrompt = document.getElementById('recruit-prompt');
        let canRecruit = false;
        if(player) {
            const nearDowned = STATE.enemies.find(en => en.downed && Math.hypot(en.x - player.x, en.y - player.y) < 60);
            if(nearDowned) canRecruit = true;
        }
        recruitPrompt.style.display = canRecruit ? 'block' : 'none';
    }

    function spawnEnemy(difficulty) {
        const r = Math.random();
        let stage = 1;
        if (difficulty > 3000 && r > 0.6) stage = 2;
        if (difficulty > 10000 && r > 0.85) stage = 3;
        if (difficulty > 25000 && r > 0.95) stage = 4;
        if (difficulty > 50000 && r > 0.98) stage = 5; 

        let mutationCount = 0;
        if (Math.random() < (difficulty / 5000)) mutationCount = 1;
        if (difficulty > 5000 && Math.random() < 0.4) mutationCount = 2;
        
        const activeMutations = [];
        const mutKeys = Object.keys(MUTATIONS).filter(k => k !== 'NONE');
        if (mutationCount === 0) activeMutations.push('NONE');
        else {
            for(let i=0; i<mutationCount; i++) activeMutations.push(mutKeys[Math.floor(Math.random() * mutKeys.length)]);
        }
        
        const side = Math.floor(Math.random()*4);
        let x, y;
        if(side===0){x=Math.random()*canvas.width; y=-50;}
        else if(side===1){x=Math.random()*canvas.width; y=canvas.height+50;}
        else if(side===2){x=-50; y=Math.random()*canvas.height;}
        else {x=canvas.width+50; y=Math.random()*canvas.height;}

        STATE.enemies.push(new Entity(x, y, 'enemy', stage, activeMutations));
    }

    function updateEntities() {
        const prevLen = STATE.squad.length;
        STATE.squad = STATE.squad.filter(s => !s.dead);
        if (STATE.squad.length < prevLen && STATE.playerIndex >= STATE.squad.length) {
            STATE.playerIndex = Math.max(0, STATE.squad.length - 1);
        }
        if (STATE.squad.length === 0) triggerGameOver();

        const player = STATE.squad[STATE.playerIndex];

        if (player) {
            let moveSpeed = player.speed * 1.5;
            if(player.slowTimer > 0) moveSpeed *= 0.5;

            if (input.keys['w']) player.y -= moveSpeed;
            if (input.keys['s']) player.y += moveSpeed;
            if (input.keys['a']) player.x -= moveSpeed;
            if (input.keys['d']) player.x += moveSpeed;
            player.x = Math.max(20, Math.min(canvas.width-20, player.x));
            player.y = Math.max(20, Math.min(canvas.height-20, player.y));
            player.angle = Math.atan2(input.mouse.y - player.y, input.mouse.x - player.x);
            
            if (input.mouseDown && Date.now() - STATE.lastShot > (player.stats.sniper ? 1500 : 200) && !player.stats.melee) {
                shoot(player);
                STATE.lastShot = Date.now();
            }
        }

        STATE.squad.forEach((s, i) => {
            if (i === STATE.playerIndex) return;
            let target = getClosest(s, STATE.enemies);
            if (target) s.updateAI(target);
            else if (player) s.updateAI(player);
        });

        STATE.enemies.forEach(e => {
            let target = getClosest(e, STATE.squad);
            e.updateAI(target);
        });
    }

    function shoot(unit) {
        if (unit.dead || unit.downed) return;
        const speed = unit.stats.sniper ? 25 : 12;
        let dmg = (20 * unit.stats.dmg) * (unit.stats.sniper ? 4 : 1);
        if(unit.team === 'player' && unit === STATE.squad[STATE.playerIndex]) dmg *= 1.5;

        let color = unit.team === 'player' ? '#00e676' : '#ff5252';
        if (unit.stats.acid) color = '#76ff03';

        const createProj = (ang) => {
            STATE.projectiles.push({
                x: unit.x, y: unit.y, 
                vx: Math.cos(ang) * speed, vy: Math.sin(ang) * speed, 
                team: unit.team, damage: dmg, shooter: unit, color: color,
                isAcid: unit.stats.acid
            });
        };
        createProj(unit.angle);
        if (unit.stats.multi) { createProj(unit.angle + 0.3); createProj(unit.angle - 0.3); }
    }

    function updateProjectiles() {
        for (let i = STATE.projectiles.length - 1; i >= 0; i--) {
            const p = STATE.projectiles[i];
            p.x += p.vx; p.y += p.vy;
            if(Math.random()<0.3) spawnParticles(p.x, p.y, p.color, 0, 1.5);

            ctx.fillStyle = p.color; ctx.shadowBlur = 5; ctx.shadowColor = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;

            let hit = false;
            const targets = p.team === 'player' ? STATE.enemies : STATE.squad;
            for (let t of targets) {
                if (t.dead || t.downed) continue;
                if (Math.hypot(p.x - t.x, p.y - t.y) < t.size + 5) {
                    t.takeDamage(p.damage, p.shooter);
                    if (p.shooter && p.shooter.stats.lifesteal && p.shooter.hp < p.shooter.maxHp) p.shooter.hp += 5; 
                    if(p.isAcid) spawnParticles(t.x, t.y, '#76ff03', 3, 3);
                    hit = true; break;
                }
            }
            if (hit || p.x<0 || p.x>canvas.width || p.y<0 || p.y>canvas.height) STATE.projectiles.splice(i, 1);
        }
    }

    function updateParticles() {
        for(let i=STATE.particles.length-1; i>=0; i--) {
            STATE.particles[i].update();
            if(STATE.particles[i].life <= 0) STATE.particles.splice(i, 1);
        }
        for(let i=STATE.effects.length-1; i>=0; i--) {
            STATE.effects[i].update();
            if(STATE.effects[i].life <= 0) STATE.effects.splice(i, 1);
        }
        for(let i=STATE.texts.length-1; i>=0; i--) {
            STATE.texts[i].update();
            if(STATE.texts[i].life <= 0) STATE.texts.splice(i, 1);
        }
    }
    
    function spawnParticles(x, y, color, speed, count) {
        for(let i=0; i<count; i++) {
            STATE.particles.push(new Particle(x, y, color, speed + Math.random(), Math.random()*3+1, 20 + Math.random()*20));
        }
    }

    function handleDeath(unit, killer) {
        if (unit.stats.boom) {
            spawnParticles(unit.x, unit.y, '#ff3d00', 8, 30);
            const targets = unit.team === 'player' ? STATE.enemies : STATE.squad;
            targets.forEach(t => { if(Math.hypot(t.x - unit.x, t.y - unit.y) < 150) t.takeDamage(50, unit); });
        }

        if (unit.team === 'enemy') {
            unit.downed = true; unit.hp = 0;
            unit.x = Math.max(50, Math.min(canvas.width - 50, unit.x));
            unit.y = Math.max(50, Math.min(canvas.height - 50, unit.y));
            spawnParticles(unit.x, unit.y, '#e53935', 6, 15);
            if (Math.random() < 0.5) STATE.sessionCoins += (unit.stage * 10);
            const bioReward = unit.stage * 15;
            STATE.biomass += bioReward;
            STATE.texts.push(new FloatingText(unit.x, unit.y - 20, `+${bioReward} BIO`, '#4caf50'));

            if (killer && killer.stats.necro && STATE.squad.length < MAX_SQUAD) {
                unit.team = 'player'; unit.downed = false; unit.hp = unit.maxHp; 
                STATE.squad.push(unit);
                const idx = STATE.enemies.indexOf(unit); if(idx > -1) STATE.enemies.splice(idx, 1);
                spawnParticles(unit.x, unit.y, '#d500f9', 4, 15);
                STATE.texts.push(new FloatingText(unit.x, unit.y - 40, "RISEN", '#d500f9'));
            } else {
                setTimeout(() => { const idx = STATE.enemies.indexOf(unit); if(idx > -1) STATE.enemies.splice(idx, 1); }, 10000);
            }
        } else {
            unit.dead = true;
            spawnParticles(unit.x, unit.y, '#4caf50', 6, 20);
        }
    }

    function triggerGameOver() {
        GAME_STATE = 'GAMEOVER';
        playerCoins += STATE.sessionCoins;
        localStorage.setItem('pf_coins', playerCoins);
        activeLoadout = [];
        localStorage.setItem('pf_loadout', JSON.stringify(activeLoadout));
        document.getElementById('final-score').innerText = STATE.score;
        document.getElementById('final-coins').innerText = STATE.sessionCoins;
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function getClosest(me, list) {
        let target = null; let dist = 9999;
        list.forEach(e => {
            if (e.downed || e.dead) return;
            const d = Math.hypot(e.x - me.x, e.y - me.y);
            if (d < dist) { dist = d; target = e; }
        });
        return target;
    }

    // --- DRAWING: NEW TEXTURE SYSTEM ---
    function applySkinTexture(c, unit, type, color) {
        c.save();
        c.clip(); // Mask texture to body shape
        const time = Date.now() / 1000;

        if (type === 'digital') { // NEON
            c.strokeStyle = 'white'; c.lineWidth = 2; c.globalAlpha = 0.5;
            const gridSize = 10;
            c.beginPath();
            for(let i=-50; i<50; i+=gridSize) {
                c.moveTo(i, -50); c.lineTo(i, 50);
                c.moveTo(-50, i); c.lineTo(50, i);
            }
            c.stroke();
        } 
        else if (type === 'magma') { // MAGMA (Replaces Blood Rage)
            c.strokeStyle = '#ff3d00'; c.lineWidth = 3; 
            c.shadowColor = '#ff3d00'; c.shadowBlur = 10;
            c.beginPath();
            // Cracks
            for(let i=0; i<5; i++) {
                c.moveTo(Math.sin(time+i)*20, Math.cos(time+i)*20);
                c.lineTo(Math.sin(time+i+1)*30, Math.cos(time+i+1)*30);
            }
            c.stroke();
            // Glowing Core
            const grad = c.createRadialGradient(0, 0, 0, 0, 0, unit.size);
            grad.addColorStop(0, '#ff9100');
            grad.addColorStop(0.5, '#ff3d00');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            c.fillStyle = grad; c.globalAlpha = 0.4 + (Math.sin(time*5)*0.2);
            c.fillRect(-unit.size, -unit.size, unit.size*2, unit.size*2);
        }
        else if (type === 'metallic') { // GOLD
            const grad = c.createLinearGradient(-unit.size, -unit.size, unit.size, unit.size);
            grad.addColorStop(0, '#ffd700');
            grad.addColorStop(0.5, '#fff');
            grad.addColorStop(1, '#ff8f00');
            c.fillStyle = grad; c.globalAlpha = 0.3;
            c.fillRect(-50, -50, 100, 100);
            // Shine line
            c.beginPath(); c.strokeStyle = 'white'; c.lineWidth=5; c.globalAlpha=0.6;
            const slide = (Date.now() % 2000) / 2000 * 100 - 50;
            c.moveTo(slide, -50); c.lineTo(slide+20, 50); c.stroke();
        }
        else if (type === 'cosmic') { // VOID
            c.fillStyle = 'white';
            for(let i=0; i<10; i++) {
                let px = Math.sin(time + i*134) * (unit.size*0.8);
                let py = Math.cos(time + i*231) * (unit.size*0.8);
                c.beginPath(); c.arc(px, py, 1.5, 0, Math.PI*2); c.fill();
            }
        }
        else if (type === 'organic') { // DEFAULT / ENEMY
            c.fillStyle = 'rgba(0,0,0,0.2)';
            for(let i=0; i<6; i++) {
                c.beginPath(); c.arc(Math.sin(i)*unit.size/2, Math.cos(i)*unit.size/2, unit.size/4, 0, Math.PI*2); c.fill();
            }
        }
        
        c.restore();
    }

    function drawCreatureBody(c, unit, color, glowColor, skinType) {
        c.save();
        c.translate(unit.x, unit.y);
        c.rotate(unit.angle);

        if (glowColor) { c.shadowBlur = 15; c.shadowColor = glowColor; }
        c.fillStyle = color; c.strokeStyle = '#050505'; c.lineWidth = 1.5;

        const time = Date.now() / 150;

        // --- STAGE 1: LARVA (Unchanged) ---
        if (unit.stage === 1) {
            c.beginPath();
            const segs = 3;
            c.arc(0, 0, unit.size, 0, Math.PI*2); 
            for(let i=segs; i>=1; i--) {
                const wiggle = Math.sin(time + i) * 3;
                c.arc(i * -8, wiggle, unit.size * (1 - (i*0.2)), 0, Math.PI*2);
            }
            c.fill();
            applySkinTexture(c, unit, skinType, color);
            c.stroke();
        } 
        
        // --- STAGE 2: WORKER (Dinosaur/Raptor) ---
        else if (unit.stage === 2) {
            const wiggle = Math.sin(time) * 3;
            
            // Tail (Thick dinosaur tail)
            c.beginPath();
            c.moveTo(-10, 5);
            c.quadraticCurveTo(-30, wiggle, -45, wiggle * 2); 
            c.quadraticCurveTo(-30, -5 + wiggle, -10, -5);
            c.fill(); c.stroke();

            // Legs (Beefy hind legs)
            c.strokeStyle = color; c.lineWidth = 4;
            c.beginPath(); c.moveTo(-5, 5); c.lineTo(-5, 15); c.lineTo(5, 20 + wiggle); c.stroke();
            c.beginPath(); c.moveTo(-5, -5); c.lineTo(-5, -15); c.lineTo(5, -20 - wiggle); c.stroke();
            c.lineWidth = 1.5; c.strokeStyle = '#000';

            // Body (Egg shape)
            c.beginPath();
            c.ellipse(0, 0, unit.size, unit.size*0.7, 0, 0, Math.PI*2);
            c.fill();
            applySkinTexture(c, unit, skinType, color);
            c.stroke();

            // Head (Snout/Raptor head)
            c.beginPath();
            c.ellipse(15, 0, unit.size*0.6, unit.size*0.5, 0, 0, Math.PI*2);
            c.rect(15, -6, 12, 12); // Snout extension
            c.fill(); c.stroke();
        }

        // --- STAGE 3: HUNTER (Black Dragon) ---
        else if (unit.stage === 3) {
            const flap = Math.sin(time * 2) * 15;
            
            // Wings
            c.fillStyle = color; c.globalAlpha = 0.8;
            c.beginPath();
            c.moveTo(5, -5); c.lineTo(35, -45 + flap); c.lineTo(15, 0); // Left Wing
            c.moveTo(5, 5); c.lineTo(35, 45 - flap); c.lineTo(15, 0);   // Right Wing
            c.fill(); c.stroke();
            c.globalAlpha = 1;

            // Tail (Long & Spiked)
            c.beginPath();
            c.moveTo(-10, 0);
            c.lineTo(-50, Math.sin(time)*5);
            c.lineWidth = 4; c.strokeStyle = color; c.stroke();
            c.lineWidth = 1.5; c.strokeStyle = '#000';

            // Body (Sleek)
            c.beginPath();
            c.moveTo(20, 0); c.lineTo(-15, -10); c.lineTo(-20, 0); c.lineTo(-15, 10); c.closePath();
            c.fill();
            applySkinTexture(c, unit, skinType, color);
            c.stroke();

            // Head (Sharp/Dragon)
            c.beginPath();
            c.moveTo(20, -8); c.lineTo(45, 0); c.lineTo(20, 8); c.fill(); c.stroke();
            // Horns
            c.strokeStyle = color;
            c.beginPath(); c.moveTo(20, -5); c.lineTo(10, -15); c.stroke();
            c.beginPath(); c.moveTo(20, 5); c.lineTo(10, 15); c.stroke();
        }

        // --- STAGE 4: TITAN (Xenomorph) ---
        else if (unit.stage === 4) {
             // Limbs (Spindly but strong)
            c.strokeStyle = '#333'; c.lineWidth = 4;
            c.beginPath(); c.moveTo(-5, -10); c.lineTo(10, -35); c.lineTo(30, -25); c.stroke(); // Front L
            c.beginPath(); c.moveTo(-5, 10); c.lineTo(10, 35); c.lineTo(30, 25); c.stroke();   // Front R
            c.beginPath(); c.moveTo(-15, -10); c.lineTo(-25, -30); c.stroke(); // Back L
            c.beginPath(); c.moveTo(-15, 10); c.lineTo(-25, 30); c.stroke();   // Back R

            // Tail (Long segmented stinger)
            const tailWag = Math.cos(time) * 10;
            c.strokeStyle = color; c.lineWidth = 6;
            c.beginPath(); c.moveTo(-10, 0); c.quadraticCurveTo(-50, tailWag, -70, tailWag*1.5); c.stroke();
            c.fillStyle = '#fff'; c.beginPath(); c.arc(-70, tailWag*1.5, 3, 0, Math.PI*2); c.fill(); // Stinger tip

            // Body (Ribbed)
            c.fillStyle = color; c.strokeStyle = '#000'; c.lineWidth = 1;
            c.beginPath(); c.ellipse(0, 0, 20, 10, 0, 0, Math.PI*2); c.fill();
            applySkinTexture(c, unit, skinType, color);
            c.stroke();
            
            // Head (Elongated Banana Shape)
            c.beginPath();
            c.ellipse(10, 0, 35, 12, 0, 0, Math.PI*2); // The long head
            c.fill(); c.stroke();
            // Inner Jaw
            c.fillStyle = '#888'; c.fillRect(35, -2, 5, 4);
        }

        // --- STAGE 5: QUEEN (The "King" / Open Maw Monster) ---
        else if (unit.stage === 5) {
            // Massive Shoulders/Armor
            c.fillStyle = color;
            c.beginPath(); c.arc(0, -20, 25, 0, Math.PI*2); c.fill(); c.stroke();
            c.beginPath(); c.arc(0, 20, 25, 0, Math.PI*2); c.fill(); c.stroke();

            // Main Body
            c.beginPath(); 
            c.ellipse(-10, 0, 50, 40, 0, 0, Math.PI*2);
            c.fill();
            applySkinTexture(c, unit, skinType, color);
            c.stroke();
            
            // The Maw (Open Mouth)
            c.fillStyle = '#000'; // Darkness inside mouth
            c.beginPath(); c.arc(35, 0, 20, 0, Math.PI*2); c.fill();
            
            // Teeth/Mandibles
            c.strokeStyle = '#fff'; c.lineWidth = 2;
            c.beginPath(); c.moveTo(35, -20); c.lineTo(45, -5); c.stroke();
            c.beginPath(); c.moveTo(35, 20); c.lineTo(45, 5); c.stroke();

            // Spikes/Crown
            c.fillStyle = color;
            c.beginPath(); c.moveTo(-20, -30); c.lineTo(-40, -50); c.lineTo(-10, -30); c.fill();
            c.beginPath(); c.moveTo(-20, 30); c.lineTo(-40, 50); c.lineTo(-10, 30); c.fill();
        }

        // --- MUTATION VISUALS ---
        if (unit.stats.tesla) {
            c.fillStyle = '#00e5ff'; c.beginPath(); c.arc(-5, 0, 6, 0, Math.PI*2); c.fill();
            c.shadowColor = '#00e5ff'; c.shadowBlur = 10;
        }
        if (unit.stats.sniper) {
            c.fillStyle = '#333'; c.fillRect(10, -3, 30, 6);
            c.fillStyle = '#00e5ff'; c.fillRect(38, -2, 2, 4);
        }
        if (unit.stats.melee) {
            c.fillStyle = '#e65100'; c.beginPath(); c.moveTo(-unit.size, -5); c.lineTo(-unit.size - 20, 0); c.lineTo(-unit.size, 5); c.fill();
        }

        // --- EYES (Modified for new shapes) ---
        if (!unit.downed && unit.stage !== 4 && unit.stage !== 5) { // Titan/Queen have no visible eyes or different eyes
            c.fillStyle = (unit.team === 'enemy' ? '#ff0' : '#00e5ff');
            c.shadowBlur = 5; c.shadowColor = c.fillStyle;
            let eyeX = unit.size/2; 
            if(unit.stage===2) eyeX = 20; // Raptor eyes
            if(unit.stage===3) eyeX = 35; // Dragon eyes
            c.beginPath(); c.arc(eyeX, -5, 2, 0, Math.PI*2); c.fill();
            c.beginPath(); c.arc(eyeX, 5, 2, 0, Math.PI*2); c.fill();
        }
        // Glowing Mouth for Queen
        if(!unit.downed && unit.stage === 5) {
             c.fillStyle = (unit.team === 'enemy' ? '#ff0' : '#00e5ff');
             c.globalAlpha = 0.5;
             c.beginPath(); c.arc(35, 0, 10, 0, Math.PI*2); c.fill();
             c.globalAlpha = 1;
        }

        c.restore();
    }

    // --- ARCHIVE SYSTEM (GALLERY) ---
    let archiveSkin = 'DEFAULT';
    let archiveAnimationId = null;

    function openArchive() {
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('archive-screen').style.display = 'flex';
        
        // Build toggles
        const controls = document.getElementById('archive-controls');
        controls.innerHTML = '';
        for(let key in SKINS) {
            const btn = document.createElement('div');
            btn.className = `skin-toggle ${archiveSkin === key ? 'active' : ''}`;
            btn.innerText = SKINS[key].name;
            btn.onclick = () => { archiveSkin = key; openArchive(); };
            controls.appendChild(btn);
        }

        if(archiveAnimationId) cancelAnimationFrame(archiveAnimationId);
        renderArchiveLoop();
    }
    
    function closeArchive() {
        if(archiveAnimationId) cancelAnimationFrame(archiveAnimationId);
        document.getElementById('archive-screen').style.display = 'none';
        document.getElementById('menu-screen').style.display = 'flex';
    }

    function renderArchiveLoop() {
        const ac = document.getElementById('archiveCanvas');
        const actx = ac.getContext('2d');
        actx.clearRect(0, 0, ac.width, ac.height);

        // Draw labels and units
        actx.font = "20px monospace"; actx.fillStyle = "#888"; actx.textAlign = "center";
        
        const labels = ["LARVA", "WORKER", "HUNTER", "TITAN", "QUEEN"];
        const spacing = 180;
        const startX = 140;
        const centerY = 200;

        for(let i=0; i<5; i++) {
            const stage = i+1;
            const x = startX + (i*spacing);
            
            actx.fillStyle = "#444";
            actx.fillText(labels[i], x, centerY + 80);
            
            // Create dummy entity for render
            const dummy = new Entity(x, centerY, 'player', stage, ['NONE']);
            
            // Mock skin selection
            equippedSkin = archiveSkin; // Temporarily swap global to render
            dummy.draw(actx);
        }
        equippedSkin = localStorage.getItem('pf_equipped') || 'DEFAULT'; // Restore actual

        archiveAnimationId = requestAnimationFrame(renderArchiveLoop);
    }

    // --- MENU LOGIC ---
    function openShop() {
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('shop-screen').style.display = 'flex';
        renderShop();
    }
    function closeShop() {
        document.getElementById('shop-screen').style.display = 'none';
        document.getElementById('menu-screen').style.display = 'flex';
        document.getElementById('menu-coins').innerText = playerCoins;
    }
    function renderShop() {
        document.getElementById('shop-coins').innerText = playerCoins;
        const grid = document.getElementById('shop-grid');
        grid.innerHTML = '';
        for (let key in SKINS) {
            const s = SKINS[key];
            const owned = unlockedSkins.includes(key);
            const isEquipped = equippedSkin === key;
            const div = document.createElement('div');
            div.className = `item-card ${owned ? 'owned' : ''} ${isEquipped ? 'selected' : ''}`;
            div.innerHTML = `
                <div style="width: 50px; height: 50px; background:${s.color}; margin: 0 auto 10px; border-radius:50%; box-shadow: 0 0 10px ${s.color}"></div>
                <h3 style="color:white; margin:5px 0;">${s.name}</h3>
                <p style="color:#aaa; font-size:12px;">${owned ? (isEquipped ? 'EQUIPPED' : 'OWNED') : s.cost + ' COINS'}</p>
            `;
            div.onclick = () => buyOrEquipSkin(key, s.cost);
            grid.appendChild(div);
        }
    }
    function buyOrEquipSkin(key, cost) {
        if (unlockedSkins.includes(key)) {
            equippedSkin = key;
            localStorage.setItem('pf_equipped', key);
        } else if (playerCoins >= cost) {
            playerCoins -= cost;
            unlockedSkins.push(key);
            equippedSkin = key;
            localStorage.setItem('pf_coins', playerCoins);
            localStorage.setItem('pf_skins', JSON.stringify(unlockedSkins));
            localStorage.setItem('pf_equipped', key);
        }
        renderShop();
    }

    function openUpgrades() {
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('upgrade-screen').style.display = 'flex';
        renderUpgrades();
    }
    function closeUpgrades() {
        document.getElementById('upgrade-screen').style.display = 'none';
        document.getElementById('menu-screen').style.display = 'flex';
        document.getElementById('menu-coins').innerText = playerCoins;
    }
    function renderUpgrades() {
        document.getElementById('upgrade-coins').innerText = playerCoins;
        const list = document.getElementById('upgrade-list');
        list.innerHTML = '';
        for(let key in UPGRADE_DATA) {
            const up = UPGRADE_DATA[key];
            const currentLvl = playerUpgrades[key] || 0;
            const isMax = currentLvl >= up.max;
            const cost = isMax ? "MAX" : up.cost[currentLvl];
            const div = document.createElement('div');
            div.className = 'upgrade-row';
            let pipsHtml = '';
            for(let i=0; i<up.max; i++) pipsHtml += `<div class="pip ${i < currentLvl ? 'active' : ''}"></div>`;
            div.innerHTML = `
                <div>
                    <h3 style="font-size:18px; color:#d500f9;">${up.name}</h3>
                    <div style="font-size:12px; color:#888;">${up.desc}</div>
                    <div class="pips" style="margin-top:5px;">${pipsHtml}</div>
                </div>
                <button class="btn" style="min-width:120px; padding:10px; font-size:16px; ${isMax?'border-color:#555;color:#555;':''}" 
                    onclick="buyUpgrade('${key}')">${cost === 'MAX' ? 'MAX' : cost + ' ðŸ’°'}</button>
            `;
            list.appendChild(div);
        }
    }
    function buyUpgrade(key) {
        const up = UPGRADE_DATA[key];
        const currentLvl = playerUpgrades[key] || 0;
        if(currentLvl >= up.max) return;
        const cost = up.cost[currentLvl];
        if(playerCoins >= cost) {
            playerCoins -= cost;
            playerUpgrades[key] = currentLvl + 1;
            localStorage.setItem('pf_coins', playerCoins);
            localStorage.setItem('pf_upgrades', JSON.stringify(playerUpgrades));
            renderUpgrades();
        }
    }

    function toggleStartStage() {
        if(playerUpgrades.startEvo > 0) {
            const max = playerUpgrades.startEvo + 1;
            preferStartStage++;
            if(preferStartStage > max) preferStartStage = 1;
            localStorage.setItem('pf_prefStage', preferStartStage);
            const btn = document.getElementById('evo-btn');
            const name = preferStartStage === 1 ? 'LARVA' : (preferStartStage === 2 ? 'WORKER' : 'SOLDIER');
            btn.innerText = `STARTING FORM: ${name}`;
        }
    }
    function openLab() {
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('lab-screen').style.display = 'flex';
        const btn = document.getElementById('evo-btn');
        if(playerUpgrades.startEvo === 0) {
            btn.style.opacity = '0.5'; btn.innerText = "LOCKED (Requires 'Genetic Memory')";
            btn.onclick = null;
        } else {
            const name = preferStartStage === 1 ? 'LARVA' : (preferStartStage === 2 ? 'WORKER' : 'SOLDIER');
            btn.innerText = `STARTING FORM: ${name}`;
            btn.onclick = toggleStartStage;
        }
        renderLab();
        updateLoadoutDisplay();
    }
    function closeLab() {
        document.getElementById('lab-screen').style.display = 'none';
        document.getElementById('menu-screen').style.display = 'flex';
        document.getElementById('menu-coins').innerText = playerCoins;
    }
    function renderLab() {
        document.getElementById('lab-coins').innerText = playerCoins;
        const grid = document.getElementById('lab-grid');
        grid.innerHTML = '';
        for (let key in MUTATIONS) {
            if (key === 'NONE') continue;
            const m = MUTATIONS[key];
            const div = document.createElement('div');
            const inLoadout = activeLoadout.includes(key);
            div.className = `item-card ${inLoadout ? 'selected' : ''}`;
            div.innerHTML = `
                <h3 style="color:${m.color}">${m.name}</h3>
                <div style="font-size:11px; color:#aaa; margin-bottom:5px;">${m.desc}</div>
                <div style="font-size:12px; color:#fff;">${m.cost} C</div>
            `;
            div.onclick = () => toggleLoadout(key, m.cost);
            grid.appendChild(div);
        }
    }
    function toggleLoadout(key, cost) {
        const idx = activeLoadout.indexOf(key);
        const maxSlots = 3 + playerUpgrades.startCount;
        if (idx > -1) {
            activeLoadout.splice(idx, 1);
            playerCoins += cost; 
        } else {
            if (activeLoadout.length >= maxSlots) return; 
            if (playerCoins >= cost) {
                playerCoins -= cost;
                activeLoadout.push(key);
            }
        }
        localStorage.setItem('pf_coins', playerCoins);
        localStorage.setItem('pf_loadout', JSON.stringify(activeLoadout));
        renderLab();
        updateLoadoutDisplay();
    }
    function updateLoadoutDisplay() {
        const display = document.getElementById('loadout-display');
        display.innerHTML = '';
        const maxSlots = 3 + playerUpgrades.startCount;
        for(let i=0; i<maxSlots; i++) {
            const mKey = activeLoadout[i];
            const div = document.createElement('div');
            div.className = `canister ${mKey ? 'filled' : ''}`;
            if(mKey) {
                const m = MUTATIONS[mKey];
                div.style.borderColor = m.color;
                div.style.boxShadow = `0 0 10px ${m.color}`;
                div.innerHTML = `<span style="color:${m.color}; font-weight:bold;">${m.name}</span>`;
            } else { div.innerText = "EMPTY"; }
            display.appendChild(div);
        }
    }
    function clearLoadout() {
        activeLoadout.forEach(key => { playerCoins += MUTATIONS[key].cost; });
        activeLoadout = [];
        localStorage.setItem('pf_coins', playerCoins);
        localStorage.setItem('pf_loadout', JSON.stringify(activeLoadout));
        renderLab();
        updateLoadoutDisplay();
    }

    // --- INPUT ---
    const input = { keys: {}, mouse: {x:0, y:0}, mouseDown: false };
    window.addEventListener('keydown', e => {
        input.keys[e.key] = true;
        if (GAME_STATE === 'PLAYING') {
            const player = STATE.squad[STATE.playerIndex];
            if (e.key === ' ' && player) {
                const cost = player.stage * 100;
                if (STATE.biomass >= cost && player.stage < 5) {
                    STATE.biomass -= cost; player.stage++; player.maxHp += 100; player.hp += 100; player.size += 8;
                    spawnParticles(player.x, player.y, '#d500f9', 5, 20);
                }
            }
            if (e.key === 'q') STATE.playerIndex = (STATE.playerIndex + 1) % STATE.squad.length;
            if (e.key === 'e') {
                let bestIdx = -1; let bestScore = -1;
                STATE.squad.forEach((s, i) => { const score = (s.stage * 10000) + s.hp; if(score > bestScore) { bestScore = score; bestIdx = i; } });
                if(bestIdx !== -1) { STATE.playerIndex = bestIdx; spawnParticles(STATE.squad[bestIdx].x, STATE.squad[bestIdx].y, '#ffffff', 5, 10); }
            }
            if (e.key === 'x') {
                const candidates = STATE.squad.filter((s, i) => i !== STATE.playerIndex);
                if(candidates.length > 0) {
                    candidates.sort((a, b) => { if (a.stage !== b.stage) return a.stage - b.stage; return a.hp - b.hp; });
                    const weakling = candidates[0]; const idx = STATE.squad.indexOf(weakling);
                    if (idx > -1) {
                        STATE.squad.splice(idx, 1);
                        const refund = weakling.stage * 40; STATE.biomass += refund;
                        STATE.texts.push(new FloatingText(weakling.x, weakling.y, `+${refund} BIO`, '#4caf50'));
                        spawnParticles(weakling.x, weakling.y, '#e53935', 3, 10);
                        if (STATE.playerIndex >= STATE.squad.length) STATE.playerIndex = Math.max(0, STATE.squad.length - 1);
                    }
                }
            }
            if (e.key === 'r') {
                const nearDowned = STATE.enemies.find(en => en.downed && Math.hypot(en.x - player.x, en.y - player.y) < 60);
                if (nearDowned && STATE.squad.length < MAX_SQUAD) {
                    nearDowned.downed = false; nearDowned.team = 'player'; nearDowned.hp = nearDowned.maxHp * 0.5;
                    const idx = STATE.enemies.indexOf(nearDowned); if(idx > -1) STATE.enemies.splice(idx, 1);
                    STATE.squad.push(nearDowned);
                    spawnParticles(nearDowned.x, nearDowned.y, '#00e676', 4, 15);
                }
            }
            if (e.key === 'f') {
                const nearDowned = STATE.enemies.find(en => en.downed && Math.hypot(en.x - player.x, en.y - player.y) < 60);
                if (nearDowned) {
                    const bio = nearDowned.stage * 50; STATE.biomass += bio;
                    STATE.texts.push(new FloatingText(nearDowned.x, nearDowned.y, `+${bio} BIO`, '#4caf50'));
                    const idx = STATE.enemies.indexOf(nearDowned); if(idx > -1) STATE.enemies.splice(idx, 1);
                    spawnParticles(nearDowned.x, nearDowned.y, '#e53935', 4, 15);
                }
            }
        }
    });

    window.addEventListener('keyup', e => input.keys[e.key] = false);
    window.addEventListener('mousemove', e => { input.mouse.x = e.clientX; input.mouse.y = e.clientY; });
    window.addEventListener('mousedown', () => input.mouseDown = true);
    window.addEventListener('mouseup', () => input.mouseDown = false);

    initGame();
</script>
</body>
</html>
